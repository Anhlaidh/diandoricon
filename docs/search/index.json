[{"content":"Welcome to Hugo theme Stack. This is your first post. Edit or delete it, then start writing!\nFor more information about this theme, check the documentation: https://stack.jimmycai.com/\nWant a site like this? Check out hugo-theme-stack-stater\nPhoto by Pawel Czerwinski on Unsplash\n","date":"2022-03-06T00:00:00Z","image":"https://diandoricon.cloud/p/hello-world/cover_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://diandoricon.cloud/p/hello-world/","title":"Hello World"},{"content":"一、简介 Arthas项目地址 GitHub\n1 https://github.com/alibaba/arthas 码云\n1 http://arthas.gitee.io/ 以下是Arthas官网介绍\n简介 Arthas 是一款线上监控诊断产品，通过全局视角实时查看应用 load、内存、gc、线程的状态信息，并能在不修改应用代码的情况下，对业务问题进行诊断，包括查看方法调用的出入参、异常，监测方法执行耗时，类加载信息等，大大提升线上问题排查效率。\n背景 通常，本地开发环境无法访问生产环境。如果在生产环境中遇到问题，则无法使用 IDE 远程调试。更糟糕的是，在生产环境中调试是不可接受的，因为它会暂停所有线程，导致服务暂停。\n开发人员可以尝试在测试环境或者预发环境中复现生产环境中的问题。但是，某些问题无法在不同的环境中轻松复现，甚至在重新启动后就消失了。\n如果您正在考虑在代码中添加一些日志以帮助解决问题，您将必须经历以下阶段：测试、预发，然后生产。这种方法效率低下，更糟糕的是，该问题可能无法解决，因为一旦 JVM 重新启动，它可能无法复现，如上文所述。\nArthas 旨在解决这些问题。开发人员可以在线解决生产问题。无需 JVM 重启，无需代码更改。 Arthas 作为观察者永远不会暂停正在运行的线程。\nArthas（阿尔萨斯）能为你做什么？ Arthas 是 Alibaba 开源的 Java 诊断工具，深受开发者喜爱。\n当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：\n这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？ 我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？ 遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？ 线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！ 是否有一个全局视角来查看系统的运行状况？ 有什么办法可以监控到 JVM 的实时运行状态？ 怎么快速定位应用的热点，生成火焰图？ 怎样直接从 JVM 内查找某个类的实例？ Arthas 支持 JDK 6+，支持 Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。\n二、 安装\u0026amp;启动 使用arthas-boot（推荐） 安装 绿色软件，直接下载即可直接启动\n下载地址\n1 https://arthas.aliyun.com/arthas-boot.jar 启动 启动命令\n1 java -jar arthas-boot.jar 若使用过程中遇到中文乱码，可在启动命令指定编码格式\n1 2 3 java -jar -Dfile.encoding=UTF-8 arthas-boot.jar java -jar -Dfile.encoding=gbk arthas-boot.jar 挂载到java进程 arthas启动后，选择需要挂载的java进程序号\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 [root@xxx ~]java -jar .\\arthas-boot.jar [INFO] JAVA_HOME: /opt/Java/jdk-11 [INFO] arthas-boot version: 3.6.9 [INFO] Found existing java process, please choose one and input the serial number of the process, eg : 1. Then hit ENTER. * [1]: 26868 com.ai.UnidocWebStartup [2]: 15232 org.jetbrains.idea.maven.server.RemoteMavenServer36 [3]: 20000 org.jetbrains.idea.maven.server.RemoteMavenServer36 [4]: 3984 org.apache.zookeeper.server.quorum.QuorumPeerMain [5]: 9936 [6]: 10468 org.jetbrains.jps.cmdline.Launcher [7]: 23480 org.jetbrains.idea.maven.server.RemoteMavenServer36 [8]: 11324 com.cmcc.unidoc.UnidocServerStartup 1 ,---. ,------. ,--------.,--. ,--. ,---. ,---. / O \\ | .--. \u0026#39;\u0026#39;--. .--\u0026#39;| \u0026#39;--\u0026#39; | / O \\ \u0026#39; .-\u0026#39; | .-. || \u0026#39;--\u0026#39;.\u0026#39; | | | .--. || .-. |`. `-. | | | || |\\ \\ | | | | | || | | |.-\u0026#39; | `--\u0026#39; `--\u0026#39;`--\u0026#39; \u0026#39;--\u0026#39; `--\u0026#39; `--\u0026#39; `--\u0026#39;`--\u0026#39; `--\u0026#39;`-----\u0026#39; wiki https://arthas.aliyun.com/doc tutorials https://arthas.aliyun.com/doc/arthas-tutorials.html version 3.6.9 main_class pid 26868 time 2023-11-17 16:12:03 [arthas@26868]$ 三、 使用 基础命令 序号 命令 说明 1 help 查看arthas命令帮助信息，可在其他命令后加-h参数查看该命令的参数信息 2 keymap keymap命令输出当前的快捷键映射表 3 cat 显示文本文件内容 4 grep 过滤内容，和 linux 命令类似 5 pwd 返回当前的工作目录，和 linux 命令类似 6 session 查看当前会话的信息，显示当前绑定的 pid 以及会话 id 7 history 打印命令历史 8 cls 清空当前屏幕区域 9 reset 重置增强类，将被 Arthas 增强过的类全部还原，Arthas 服务端stop时会重置所有增强过的类 10 quit 退出当前 Arthas 客户端，其他 Arthas 客户端不受影响。等同于exit、logout、q三个指令 11 stop 提示关闭 Arthas 服务端，所有 Arthas 客户端全部退出 1.help：查看arthas命令帮助信息 查看arthas命令帮助信息，可在其他命令后加-h参数查看该命令的参数信息\n2.keymap：输出当前的快捷键映射表 输出当前的快捷键映射表\n3.cat：打印文件内容 打印文件内容，和 linux 里的 cat 命令类似。\n4.grep：过滤内容 过滤内容，类似传统的grep命令。\n5.pwd：返回当前的工作目录 返回当前的工作目录，和 linux 命令类似\n6.session：查看当前会话的信息 查看当前会话的信息，显示当前绑定的 pid 以及会话 id。\n7.history：打印命令历史 1 2 3 4 5 #查看最近执行的3条指令 $ history 3 269 thread 270 cls 271 history 3 8.cls：清空当前屏幕区域 清空当前屏幕区域\n9.reset：重置增强类 将被 Arthas 增强过的类全部还原，Arthas 服务端stop时会重置所有增强过的类\n10.quit：退出当前 Arthas 客户端 退出当前 Arthas 客户端，其他 Arthas 客户端不受影响。等同于exit、logout、q三个指令。\n只是退出当前 Arthas 客户端，Arthas 的服务器端并没有关闭，所做的修改也不会被重置。\n11.stop：关闭 Arthas 服务端，所有 Arthas 客户端全部退出。 关闭 Arthas 服务器之前，会重置掉所有做过的增强类。但是用 redefine 重加载的类内容不会被重置。\n核心命令 序号 命令 说明 1 monitor 监控方法的执行情况 2 watch 观察方法调用情况 3 trace 根据路径追踪，并记录消耗时间 4 stack 追踪方法被调用的调用路径 5 tt 记录方法执行数据的时空隧道 6 dashboard 当前系统的实时数据面板 7 ognl 执行ognl表达式 8 sc 查看 JVM 已加载的类信息 9 sm 查看 JVM 已加载类的方法信息 1. monitor：监控方法的执行情况 字段说明 监控项 说明 timestamp 时间戳 class Java 类 method 方法（构造方法、普通方法） total 调用次数 success 成功次数 fail 失败次数 rt 平均 RT fail-rate 失败率 参数说明 方法拥有一个命名参数 [c:]，意思是统计周期（cycle of output），拥有一个整型的参数值\n参数名称 参数说明 class-pattern 类名表达式匹配 method-pattern 方法名表达式匹配 condition-express 条件表达式 [E] 开启正则表达式匹配，默认为通配符匹配 [c:] 统计周期，默认值为 120 秒 [b] 在方法调用之前计算 condition-express [m \u0026lt;arg\u0026gt;] 指定 Class 最大匹配数量，默认值为 50。长格式为[maxMatch \u0026lt;arg\u0026gt;]。 使用参考 监控com.ai.controller.TesttController类的arthasTest方法，并且每5S更新一次状态。\n1 $ monitor com.ai.controller.TesttController arthasTest -c 5 通过接口调用arthasTest方法后，监控到调用情况：\n2.watch：观察方法调用情况 让你能方便的观察到指定函数的调用情况。\n能观察到的范围为：返回值、抛出异常、入参，通过编写 OGNL 表达式进行对应变量的查看。\n参数说明 watch 的参数比较多，主要是因为它能在 4 个不同的场景观察对象\n参数名称 参数说明 class-pattern 类名表达式匹配 method-pattern 函数名表达式匹配 express 观察表达式，默认值：{params, target, returnObj} condition-express 条件表达式 [b] 在函数调用之前观察 [e] 在函数异常之后观察 [s] 在函数返回之后观察 [f] 在函数结束之后(正常返回和异常返回)观察 [E] 开启正则表达式匹配，默认为通配符匹配 [x:] 指定输出结果的属性遍历深度，默认为 1，最大值是 4 [m \u0026lt;arg\u0026gt;] 指定 Class 最大匹配数量，默认值为 50。长格式为[maxMatch \u0026lt;arg\u0026gt;]。 提示\n观察表达式，默认值是{params, target, returnObj}\n使用参考 观察com.ai.controller.TesttController类的arthasTest方法的入参和返回值，结果向下解析三层\n1 $ watch com.ai.controller.TesttController arthasTest \u0026#34;{params, returnObj}\u0026#34; -x 3 调用该方法的入参\u0026amp;返回值\n观察到方法执行的结果：\n3.trace：根据路径追踪，并记录消耗时间 对方法内部调用路径进行追踪，并输出方法路径上的每个节点上耗时。\n参数说明 参数名称 参数说明 class-pattern 类名表达匹配 method-pattern 方法名表达式匹配 condition-express 条件表达式，使用OGNL表达式 [E] 开启正则表达式匹配，默认是通配符匹配 [n:] 设置命令执行次数 #cost 方法执行耗时，单位是毫秒 使用参考 增加一个方法timeConsumingMethod，该方法模拟耗时操作，并在com.ai.controller.TesttController类的arthasTest方法中调用该方法\n1 2 3 private void timeConsumingMethod() throws InterruptedException { Thread.sleep(1000); } 追踪arthasTest方法\n1 $ trace com.ai.controller.TesttController arthasTest 调用arthasTest方法，查看trace输出结果：\n可以看到方法的内部调用路径以及耗时都清晰的展示出来\n提示：java.* 下的函数调用默认会忽略掉。通过增加--skipJDKMethod false参数可以打印出来。\n4.stack：输出当前方法被调用的调用路径 输出当前方法被调用的调用路径 很多时候我们都知道一个方法被执行，但这个方法被执行的路径非常多，或者你根本就不知道这个方法是从那里被执行了，此时你需要的是 stack 命令。\n参数说明 参数名称 参数说明 class-pattern 类名表达式匹配 method-pattern 方法名表达式匹配 condition-express 条件表达式，OGNL [E] 开启正则表达式匹配，默认为通配符匹配 [n:] 执行次数限制 使用参考 观察com.ai.controller.TesttController类的timeConsumingMethod调用路径\n1 $ stack com.ai.controller.TesttController timeConsumingMethod 可以看到该方法的调用栈被打印出来\n5.tt：记录方法执行数据的时空隧道 time-tunnel 方法执行数据的时空隧道，\n记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测\nwatch 虽然很方便和灵活，但需要提前想清楚观察表达式的拼写，这对排查问题而言要求太高，因为很多时候我们并不清楚问题出自于何方，只能靠蛛丝马迹进行猜测。这个时候如果能记录下当时方法调用的所有入参和返回值、抛出的异常会对整个问题的思考与判断非常有帮助。于是乎，TimeTunnel 命令就诞生了。\n作用：记录指定方法每次调用的入参和返回值，并后期还可以对这些信息进行观测\n字段说明 表格字段 字段解释 INDEX 时间片段记录编号，每一个编号代表着一次调用，后续 tt 还有很多命令都是基于此编号指定记录操作，非常重要。 TIMESTAMP 方法执行的本机时间，记录了这个时间片段所发生的本机时间 COST(ms) 方法执行的耗时 IS-RET 方法是否以正常返回的形式结束 IS-EXP 方法是否以抛异常的形式结束 OBJECT 执行对象的hashCode()，注意，曾经有人误认为是对象在 JVM 中的内存地址，但很遗憾他不是。但他能帮助你简单的标记当前执行方法的类实体 CLASS 执行的类名 METHOD 执行的方法名 参数说明 tt的参数 说明 -t 记录某个方法在一个时间段中的调用 -l 显示所有已经记录的列表 -n 次数 只记录多少次 -s 表达式 搜索表达式 -i 索引号 查看指定索引号的详细调用信息 -p 重新调用：指定的索引号时间碎片 使用参考 记录某个方法的调用时空隧道\n1 $ tt -t com.ai.controller.TesttController arthasTest 查看index为1000的调用详情\n1 $ tt -i 1000 复现index为1000的调用，使用当时的入参再次调用方法\n1 $ tt -i 1000 -p 6.dashboard：当前系统的实时数据面板 输入 q 或者 Ctrl+C 可以退出dashboard命令\n字段说明 表格字段 字段解释 ID Java 级别的线程 ID，注意这个 ID 不能跟 jstack 中的 nativeID 一一对应。 NAME 线程名 GROUP 线程组名 PRIORITY 线程优先级, 1~10 之间的数字，越大表示优先级越高 STATE 线程的状态 CPU% 线程的 cpu 使用率。比如采样间隔 1000ms，某个线程的增量 cpu 时间为 100ms，则 cpu 使用率=100/1000=10% DELTA_TIME 上次采样之后线程运行增量 CPU 时间，数据格式为秒 TIME 线程运行总 CPU 时间，数据格式为分:秒 INTERRUPTED 线程当前的中断位状态 DAEMON 是否是 daemon 线程 参数说明 参数名称 参数说明 [i:] 刷新实时数据的时间间隔 (ms)，默认 5000ms [n:] 刷新实时数据的次数 使用参考 查看实时数据面板，每10秒刷新一次，刷新3次后退出面板\n1 $ dashboard -i 10000 -n 3 7.ognl：执行ognl表达式 参数说明 参数名称 参数说明 express 执行的表达式 [c:] 执行表达式的 ClassLoader 的 hashcode，默认值是 SystemClassLoader [classLoaderClass:] 指定执行表达式的 ClassLoader 的 class name [x] 结果对象的展开层次，默认值 1 使用参考 调用静态方法\n1 $ ognl \u0026#39;@java.lang.System@out.println(\u0026#34;hello\u0026#34;)\u0026#39; 查看静态属性\n1 $ ognl \u0026#39;@com.ai.controller.TesttController@IP_UNKNOWN\u0026#39; 获取某类的Logger，并使用该Logger打印日志\n1 $ ognl \u0026#39;#logger=@com.ai.controller.TesttController@logger,#logger.info(\u0026#34;hello world!!\u0026#34;)\u0026#39; 利用hutool的spring工具类获取spring bean, 构建一个map作为入参并调用bean的方法\n1 $ ognl \u0026#39;#req=#{\u0026#34;a\u0026#34;:\u0026#34;value\u0026#34;,\u0026#34;b\u0026#34;:\u0026#34;value\u0026#34;}, #bean=@cn.hutool.extra.spring.SpringUtil@getBean(\u0026#34;testtController\u0026#34;), #bean.arthasTest(#req)\u0026#39; ognl表达式常用语法 调用静态方法\n@全路径类目@静态方法名(\u0026ldquo;参数\u0026rdquo;)\n1 z$ ognl \u0026#39;@java.lang.System@out.println(\u0026#34;hello\u0026#34;)\u0026#39; 调用静态属性\n@全路径类目@静态属性名\n1 $ ognl \u0026#39;@cn.rapdog.OgnlTest@MAIL_TEMPLATE\u0026#39; 赋值临时变量\n#临时变量名=ognl表达式\n1 $ ognl \u0026#39;#a=@cn.rapdog.OgnlTest@MAIL_TEMPLATE\u0026#39; 将方法A的返回作为方法B的入参\n1 $ ognl \u0026#39;#a=@cn.rapdog.OgnlTest@methodA(), @cn.rapdog.OgnlTest@methodB(#a)\u0026#39; 执行多行表达式，赋值给临时变量，返回一个List\n1 $ ognl \u0026#39;#value1=@cn.rapdog.OgnlTest@methodA(), #value2=@cn.rapdog.OgnlTest@methodB(#value1), {#value1,#value2}\u0026#39; 方法入参是简单类型的列表\n1 $ ognl \u0026#39;@cn.rapdog.OgnlTest@printList({\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;})\u0026#39; 方法入参是一个对象\n先创建一个对象，再将这个对象作为方法入参传入方法\n1 $ ognl \u0026#39;#obj=new cn.rapdog.User(\u0026#34;rapdog\u0026#34;,18,true), @cn.rapdog.OgnlTest@printObject(#obj)\u0026#39; 如果只能使用对象的无参构造方法，可以调用对象的set方法设置属性\n1 $ ognl \u0026#39;#obj=new cn.rapdog.User(), #obj.setName(\u0026#34;rapdog\u0026#34;), #obj.setAge(18), #obj.setGender(true), @cn.rapdog.OgnlTest@printObject(#obj)\u0026#39; 方法入参是一个map\n1 $ ognl \u0026#39;#inputmap=#{\u0026#34;key1\u0026#34;:\u0026#34;value1\u0026#34;,\u0026#34;key2\u0026#34;:\u0026#34;value2\u0026#34;}, @cn.rapdog.OgnlTest@printObject(#inputmap)\u0026#39; 访问对象的属性\n1 $ ognl \u0026#39;#user=new cn.rapdog.User(\u0026#34;rapdog\u0026#34;,18,true), #user.name\u0026#39; 或调用对象的get方法\n1 $ ognl \u0026#39;#user=new cn.rapdog.User(\u0026#34;rapdog\u0026#34;,18,true), #user.getAge()\u0026#39; 通过下标访问数组的元素\n1 $ ognl \u0026#39;{\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;}[0]\u0026#39; 通过key访问Map的value\n1 $ ognl \u0026#39;#{\u0026#34;key1\u0026#34;:\u0026#34;value1\u0026#34;,\u0026#34;key2\u0026#34;:\u0026#34;value2\u0026#34;}[\u0026#34;key1\u0026#34;]\u0026#39; 8.sc：查看 JVM 已加载的类信息 “Search-Class” 的简写，这个命令能搜索出所有已经加载到 JVM 中的 Class 信息，这个命令支持的参数有 [d]、[E]、[f] 和 [x:]。\nsc 默认开启了子类匹配功能，也就是说所有当前类的子类也会被搜索出来，想要精确的匹配，请打开options disable-sub-class true开关\n参数说明 参数名称 参数说明 class-pattern 类名表达式匹配 method-pattern 方法名表达式匹配 [d] 输出当前类的详细信息，包括这个类所加载的原始文件来源、类的声明、加载的 ClassLoader 等详细信息。 如果一个类被多个 ClassLoader 所加载，则会出现多次 [E] 开启正则表达式匹配，默认为通配符匹配 [f] 输出当前类的成员变量信息（需要配合参数-d 一起使用） [x:] 指定输出静态变量时属性的遍历深度，默认为 0，即直接使用 toString 输出 [c:] 指定 class 的 ClassLoader 的 hashcode [classLoaderClass:] 指定执行表达式的 ClassLoader 的 class name [n:] 具有详细信息的匹配类的最大数量（默认为 100） 使用参考 查看某类的详细信息\n1 $ sc -d cn.rapdog.OgnlTest 查看某类的详细信息\u0026amp;成员变量信息\n1 $ sc -d -f cn.rapdog.OgnlTest 9.sm：查看已加载类的方法信息 查看方法列表\n1 $ sm cn.rapdog.OgnlTest 查看方法详细信息\n1 $ -d sm cn.rapdog.OgnlTest 10.vmtool：查看内存中的实例/强制GC 获取内存中的对象\n提示： 通过 --limit参数，可以限制返回值数量，避免获取超大数据时对 JVM 造成压力。默认值是 10。\n1 $ vmtool --action getInstances --className java.lang.String --limit 10 指定classloader获取对象\n利用sc命令获取类的classloader hash\n1 $ sc -d org.spriogframework.context.ApplicationContext 再指定classloader\n1 $ vmtool --action getInstances -c 18b4aac2 --className org.springframework.context.ApplicationContext 执行表达式\n提示\ngetInstances action 返回结果绑定到instances变量上，它是数组。可以通过--express参数执行指定的表达式。\n1 $ vmtool --action getInstances -c 18b4aac2 --className org.springframework.context.ApplicationContext --express \u0026#39;instances[0].getBeanDefinitionNames()\u0026#39; 强制GC\n1 $ vmtool --action forceGc 示例场景 场景一：手动触发bean的方法 某工程的定时任务无法正常触发，需要手动触发某bean中的方法\n寻找spring ApplicationContext的classloader hash\n1 $ sc -d org.springframework.context.ApplicationContext 获取目标bean\n1 $ vmtool --action getInstances -c 18b4aac2 --className org.springframework.context.ApplicationContext --express \u0026#39;instances[0].getBean(\u0026#34;ibmExcelService\u0026#34;)\u0026#39; -x 3 调用目标bean的方法\n1 $ vmtool --action getInstances -c 18b4aac2 --className org.springframework.context.ApplicationContext --express \u0026#39;instances[0].getBean(\u0026#34;ibmExcelService\u0026#34;).staffExcel(\u0026#34;SYNCID#20231212\u0026#34;)\u0026#39; 场景二：修改private属性 某接口使用了SYSCODE字段，该字段使用@Value注解绑定spring-boot配置中的值，需要修改该字段\n1 2 3 4 5 6 7 8 9 public class TesttController { @Value(\u0026#34;${log4x.audit.opLog.sysCode}\u0026#34;) private String SYSCODE; @PostMapping(\u0026#34;/arthasTest\u0026#34;) public String arthasTest(@RequestBody Map\u0026lt;String, Object\u0026gt; req) { return SYSCODE; } } 使用tt命令开始记录该接口的调用记录，随后调用接口，找到本次调用的index\n1 $ tt -t com.ai.controller.TesttController arthasTest 调用接口，查看tt命令记录的调用记录，发现调用的index为1000\n读取类中属性\n1 $ tt -i 1000 -w \u0026#39;target.SYSCODE\u0026#39; 修改该属性\n1 $ tt -i 1000 -w \u0026#39;target.SYSCODE=\u0026#34;JCNL\u0026#34;\u0026#39; 报错：\u0026ldquo;Error during processing the command: java.lang.IllegalAccessError, message:By default, strict mode is true, not allowed to set object properties. Want to set object properties, execute options strict false, please check $HOME/logs/arthas/arthas.log for more details.\u0026rdquo;\nArthas默认设置不允许修改字段，需要通过运行options strict false命令来修改这一配置\n再次调用接口，发现返回已经变为了刚才修改的JCNL\n","date":"2023-12-27T11:18:03Z","permalink":"https://diandoricon.cloud/p/arthas/","title":"Arthas"},{"content":"write for me create 默认模版 hugo new content/post/arthas.md\ntechnology\n1 hugo new -k tb content/post/arthas.md config https://gohugo.io/content-management/front-matter/ ","date":"2023-12-18T13:05:43Z","permalink":"https://diandoricon.cloud/p/hugo/","title":"Hugo"},{"content":"算法 数据结构 队列(Queue) 栈(Stack) 树(Tree) 遍历 前序遍历 PreOrderTraversal\n- 根左右 - 树状结构展示（注意左右子树的顺序） 中序遍历 InorderTraversal - 左根右 - 二叉搜索树的中序遍历按升序或降序处理节点 后序遍历 postOrderTraversal\n- 左右根 - 适用于一些先子后父的操作 层次遍历\n- 层级遍历 - 计算二叉树的高度 - 判断是否为完全二叉树\n二叉搜索树 任意一个节点的值都大于左子树所有结点的值 任意一个节点的值都小于右子树所有节点的值 他的左右子树也是一颗二叉搜索树 二叉搜索树可以大大提高搜索数据的效率 元素必须剧有可比较性 接口设计 int size() //元素的数量\nboolean isEmpty() //是否为空\nvoid clear() //清空所有元素\nvoid add(E element) //添加元素\nvoid remove(E element) //删除元素\nboolean contains(E element )//是否包含元素\n元素没有索引的概念 前驱节点 中序遍历的前一个节点 后继节点 中序遍历的后一个节点 二叉树(BinaryTree) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 package notes.Java.JavaLearning_Advanced.Tree; import notes.Java.JavaLearning_Advanced.Tree.Util.TreePrinter; import java.util.LinkedList; import java.util.Queue; /** * @Description: * @author: Anhlaidh * @date: 2020/4/5 0005 22:44 */ public class BinaryTree\u0026lt;E\u0026gt; { protected int size; Node\u0026lt;E\u0026gt; root; public Node\u0026lt;E\u0026gt; getRoot() { return root; } public int size() { return 0; } public boolean isEmpty() { return size == 0; } public void clear() { size = 0; root = null; } /* * 中序遍历 * 左根右 * 因为是二叉搜索树，所以中序遍历为有序 * */ public void inOrderTraversal(Visitor\u0026lt;E\u0026gt; visitor) { inOrderTraversal(root,visitor); } private void inOrderTraversal(Node\u0026lt;E\u0026gt; node,Visitor\u0026lt;E\u0026gt; visitor) { if (visitor==null||node==null) { return;} inOrderTraversal(node.left,visitor); visitor.visit(node.element); inOrderTraversal(node.right,visitor); } /* * 前序遍历 * 根左右 * */ public void preOrderTraversal(Visitor\u0026lt;E\u0026gt; visitor) { preOrderTraversal(root,visitor); } private void preOrderTraversal(Node\u0026lt;E\u0026gt; node,Visitor\u0026lt;E\u0026gt; visitor) { if (visitor==null||node==null) { return;} visitor.visit(node.element); preOrderTraversal(node.left,visitor); preOrderTraversal(node.right,visitor); } /* * 后序遍历 * 左右根 * */ public void postOderTraversal(Visitor\u0026lt;E\u0026gt; visitor) { postOderTraversal(root,visitor); } private void postOderTraversal(Node\u0026lt;E\u0026gt; node,Visitor\u0026lt;E\u0026gt; visitor) { if (visitor==null||node==null) { return;} postOderTraversal(node.left,visitor); postOderTraversal(node.right,visitor); visitor.visit(node.element); } /* * 层序遍历 * * */ public void levelOrderTraversal(Visitor visitor) { if (root==null) { return;} Queue\u0026lt;Node\u0026lt;E\u0026gt;\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(root); while (!queue.isEmpty()) { Node\u0026lt;E\u0026gt; node = queue.poll(); visitor.visit(node.element); if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } } } private Node\u0026lt;E\u0026gt; predecessor(Node\u0026lt;E\u0026gt; node) { if (node==null) { return null;} //前驱节点在左子树中 Node\u0026lt;E\u0026gt; p = node.left; if (p != null) { while (p.right != null) { p = p.right; } return p; } //从父节点，祖父节点中寻找前驱节点 while (node.parent != null \u0026amp;\u0026amp; node == node.parent.left) { node = node.parent; } return node.parent; } protected Node\u0026lt;E\u0026gt; successor(Node\u0026lt;E\u0026gt; node) { if (node==null) { return null;} //前驱节点在左子树中 Node\u0026lt;E\u0026gt; p = node.right; if (p != null) { while (p.left != null) { p = p.left; } return p; } //从父节点，祖父节点中寻找前驱节点 while (node.parent != null \u0026amp;\u0026amp; node == node.parent.right) { node = node.parent; } return node.parent; } /* * * 计算高度 * 递归 * */ public int height() { return height(root); } private int height(Node\u0026lt;E\u0026gt; node) { if (node == null) { return 0; } return 1 + Math.max(height(node.left), height(node.right)); } public boolean isComplete() { if (root==null) { return false;} Queue\u0026lt;Node\u0026lt;E\u0026gt;\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.add(root); boolean leaf = false; while (!queue.isEmpty()) { Node\u0026lt;E\u0026gt; node = queue.poll(); if (leaf \u0026amp;\u0026amp; !node.isLeaf()) { return false; } if (node.left != null) { queue.offer(node.left); } else if (node.right != null) { return false; } if (node.right != null) { queue.offer(node.right); } else { leaf = true; } } return true; } protected static class Node\u0026lt;E\u0026gt; implements TreePrinter.PrintableNode { E element; Node\u0026lt;E\u0026gt; left; Node\u0026lt;E\u0026gt; right; Node\u0026lt;E\u0026gt; parent; public Node(E element, Node\u0026lt;E\u0026gt; parent) { this.element = element; this.parent = parent; } @Override public String toString() { if (parent==null) { return element+\u0026#34;\u0026#34;;} return element + \u0026#34;_P(\u0026#34; + parent.element + \u0026#34;)\u0026#34;; } public boolean isLeaf() { return left == null \u0026amp;\u0026amp; right == null; } public boolean hasTwoChildren() { return left != null \u0026amp;\u0026amp; right != null; } public boolean isLeftChild() { return parent != null \u0026amp;\u0026amp; this == parent.left; } public boolean isRightChild() { return parent != null \u0026amp;\u0026amp; this == parent.right; } @Override public TreePrinter.PrintableNode getLeft() { return left; } @Override public TreePrinter.PrintableNode getRight() { return right; } @Override public String getText() { return element.toString(); } } public interface Visitor\u0026lt;E\u0026gt; { void visit(E element); } protected Node\u0026lt;E\u0026gt; createNode(E element, Node\u0026lt;E\u0026gt; parent) { return new Node\u0026lt;\u0026gt;(element, parent); } } BST 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 package notes.Java.JavaLearning_Advanced.Tree; import java.util.Comparator; /** * @Description: * @author: Anhlaidh * @date: 2020/4/3 0003 21:19 */ public class BST\u0026lt;E\u0026gt; extends BinaryTree implements IBinarySearchTree\u0026lt;E\u0026gt;{ Comparator\u0026lt;E\u0026gt; comparator; public BST(Comparator\u0026lt;E\u0026gt; comparator) { this.comparator = comparator; } public BST() { comparator = null; } private void elementNotNullCheck(E element) { if (element == null) { throw new IllegalArgumentException(\u0026#34;element must not be null\u0026#34;); } } public void add(E element) { if (root == null) {//添加第一个节点 root = createNode(element, null); size++; afterAdd(root); return; } //添加的不是第一个节点 //找到父节点 Node\u0026lt;E\u0026gt; parent = null; Node\u0026lt;E\u0026gt; node = root; int cmp = 0; while (node != null) { cmp = compare(element, node.element); parent = node; if (cmp \u0026gt; 0) { node = node.right; } else if (cmp \u0026lt; 0) { node = node.left; } else { node.element = element; return;//两个数字相同时 } } //看看插入到父节点的哪个位置 Node\u0026lt;E\u0026gt; newNode = createNode(element, parent); if (cmp \u0026gt; 0) { parent.right = newNode; } else { parent.left = newNode; } size++; afterAdd(newNode); } protected void afterAdd(Node\u0026lt;E\u0026gt; node) { } public void remove(E element) { remove(node(element)); } private void remove(Node\u0026lt;E\u0026gt; node) { if (node==null) { return;} size--; //度为2的节点 if (node.hasTwoChildren()) { //找到后继节点 Node\u0026lt;E\u0026gt; p = successor(node); //用后继节点覆盖度为2的节点的值 node.element = p.element; //删除后继节点 node = p;//TODO 我认为不是很妥 } //删除node节点(node的度必然是0或1) Node\u0026lt;E\u0026gt; replacement = node.left != null ? node.left : node.right; //node是度为1 的节点 if (replacement != null) { //更改parent replacement.parent = node.parent; //更改parent的left、right指向 if (node.parent != null) { root = replacement; } else if (node == node.parent.left) { node.parent.left = replacement; } else {// node = node.parent.right node.parent.right = replacement; } } else if (node.parent == null) {//node是叶子节点并且是根节点 root = null; } else {//node是叶子节点，但不是根节点 if (node == node.parent.left) { node.parent.left = null; } else { node.parent.right = null; } } } private Node\u0026lt;E\u0026gt; node(E element) { Node\u0026lt;E\u0026gt; p = root; while (p != null) { int cmp = compare(element, p.element); if (cmp \u0026lt; 0) { p = p.left; } if (cmp==0) { return p;} if (cmp \u0026gt; 0) { p = p.right; } } return null; } public boolean contains(E element) { return node(element) != null; } private int compare(E e1, E e2) { if (comparator != null) { return comparator.compare(e1, e2); } return ((Comparable\u0026lt;E\u0026gt;) e1).compareTo(e2); } } AVL 平衡因子(Balance Factor)：某节点的左右子树高度 AVL树的特点 每个节点的平衡因子只可能是1、0、-1(绝对值\u0026lt;=1，如果超过1，称之为 \u0026ldquo;失衡\u0026rdquo;) 每个节点的左右子树高度差不超过1 搜索添加删除的时间复杂度是O(Logn) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 package notes.Java.JavaLearning_Advanced.Tree; import java.util.Comparator; /** * @Description: * @author: Anhlaidh * @date: 2020/4/5 0005 23:07 */ public class AVLTree\u0026lt;E\u0026gt; extends BST\u0026lt;E\u0026gt; { public AVLTree(Comparator\u0026lt;E\u0026gt; comparator) { super(comparator); } public AVLTree() { this(null); } @Override protected void afterAdd(Node\u0026lt;E\u0026gt; node) { do { if (isBalanced(node)) { //更新高度 updateHeight(node); } else { //恢复平衡 reBalance(node); //整棵树恢复平衡 break; } } while ((node = node.parent) != null); } private void reBalance(Node\u0026lt;E\u0026gt; grand) { Node\u0026lt;E\u0026gt; parent = ((AVLNode\u0026lt;E\u0026gt;) grand).tallerChild(); Node\u0026lt;E\u0026gt; node = ((AVLNode) parent).tallerChild(); if (parent.isLeftChild()) { if (node.isLeftChild()) {//LL rotateRight(grand); } else {//LR rotateLeft(parent); rotateRight(grand); } } else { if (node.isLeftChild()) {//RL rotateRight(parent); rotateLeft(grand); } else {//RR rotateLeft(grand); } } } private void rotateLeft(Node\u0026lt;E\u0026gt; grand) { Node\u0026lt;E\u0026gt; parent = grand.right; Node\u0026lt;E\u0026gt; child = parent.left; grand.right = child; parent.left = grand; afterRotate(grand, parent, child); } private void rotateRight(Node\u0026lt;E\u0026gt; grand) { Node\u0026lt;E\u0026gt; parent = grand.left; Node\u0026lt;E\u0026gt; child = parent.right; grand.left = child; parent.right = grand; afterRotate(grand, parent, child); } private void afterRotate(Node\u0026lt;E\u0026gt; grand, Node\u0026lt;E\u0026gt; parent, Node\u0026lt;E\u0026gt; child) { parent.parent = grand.parent; // 让parent成为子树的根节点 if (grand.isLeftChild()) { grand.parent.left = parent; } else if (grand.isRightChild()) { grand.parent.right = parent; }else { root = parent; } if (child != null) { child.parent = grand; } grand.parent = parent; updateHeight(grand); updateHeight(parent); } class AVLNode\u0026lt;E\u0026gt; extends Node\u0026lt;E\u0026gt; { int height; public AVLNode(E element, Node\u0026lt;E\u0026gt; parent) { super(element, parent); } public int balanceFactor() { int leftHeight = left==null?0:((AVLNode\u0026lt;E\u0026gt;)left).height; int rightHeight = right == null ? 0 : ((AVLNode\u0026lt;E\u0026gt;) right).height; return leftHeight - rightHeight; } public void updateHeight() { int leftHeight = left == null ? 0 : ((AVLNode\u0026lt;E\u0026gt;) left).height; int rightHeight = right == null ? 0 : ((AVLNode\u0026lt;E\u0026gt;) right).height; height = 1 + Math.max(leftHeight, rightHeight); } public Node\u0026lt;E\u0026gt; tallerChild() { int leftHeight = left==null?0:((AVLNode\u0026lt;E\u0026gt;)left).height; int rightHeight = right == null ? 0 : ((AVLNode\u0026lt;E\u0026gt;) right).height; if (leftHeight \u0026gt; rightHeight) { return left;} if (leftHeight \u0026lt; rightHeight) { return right;} return isLeftChild() ? left : right; } } private boolean isBalanced(Node\u0026lt;E\u0026gt; node) { return Math.abs(((AVLNode\u0026lt;E\u0026gt;) node).balanceFactor()) \u0026lt;= 1; } private void updateHeight(Node\u0026lt;E\u0026gt; node) { ((AVLNode\u0026lt;E\u0026gt;) node).updateHeight(); } @Override protected Node createNode(Object element, Node parent) { return new AVLNode(element, parent); } } 红黑树 图(Map) 排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 package HomeWork.sort; import java.util.*; /** * @Description: * @author: Anhlaidh * @date: 2020/3/13 0013 15:36 */ public class SortImpl implements ISort { /** * 快速排序 O(nLog2n) * 一分为三,第一个数字为mid,分成比mid小,比mid大两个数组 * 可知左边的一定比mid小,右边的一定比mid大 * 递归拆分,合并即可获得有序数组 * @param array 数组 * @return 有序数组 */ @Override public int[] QuickSort(int[] array) { if (array.length\u0026lt;=1) { return array;} int mid = array[0]; int left=1; int current=0; int right=array.length-1; while (left!=right){ while (left!=right){ if (array[right]\u0026gt;=mid) { right--;}else { array[current] = array[right]; current = right; right--; break; } } while (left!=right){ if (array[left]\u0026lt;mid) { left++;}else { array[current] = array[left]; current = left; left++; break; } } } int[] l = Arrays.copyOfRange(array, 0, current); int[] r = Arrays.copyOfRange(array, current + 1, array.length); int[] l_sort = QuickSort(l); int[] r_sort = QuickSort(r); array[current] = mid; System.arraycopy(l_sort,0,array,0,l_sort.length); System.arraycopy(r_sort,0,array,current+1,r_sort.length); return array; } /** * 归并排序O(nLog2n) * 将数组一分为二一分为二,递归拆分成只有一个数字 * 根据大小,来组合成有序数组 * @param array 无序数组 */ @Override public void MergeSort(int[] array) { int mid = array.length/2; int[] left = null; int[] right=null; if (array.length\u0026gt;1){ //TODO 分成两个数组 left = Arrays.copyOfRange(array, 0, mid); right = Arrays.copyOfRange(array, mid , array.length); MergeSort(left); MergeSort(right); } Merge(array,left,right); } private void Merge(int[] array, int[] left, int[] right) { if (left==null||right==null) { array=array;}else { int l=0; int r=0; int i=0; while (i\u0026lt;array.length){ if (left[l]\u0026lt;right[r]){ array[i] = left[l]; l++; i++; if (l\u0026gt;=left.length){ while (r\u0026lt;right.length){ array[i] = right[r]; r++; i++; } } } else{ array[i] = right[r]; r++; i++; if (r\u0026gt;=right.length){ while (l\u0026lt;left.length){ array[i] = left[l]; i++; l++; } } } } } } /** * 冒泡排序O(n2) * 依次比较,当前数字大于比较数字则交换,否则不变,将大数冒到最右 * 循环冒泡,得到有序数组 * @param array 无序数组 */ @Override public void BubbleSort(int[] array) { for (int j = array.length; j \u0026gt; 0; j--) { for (int i = 0; i \u0026lt; j - 1; i++) { if (array[i] \u0026gt; array[i + 1]) { int temp = array[i]; array[i] = array[i + 1]; array[i + 1] = temp; } } } } /** * 选择排序O(n2) * 遍历数组,找到最小值,与array[i]交换,以此类推 * @param array */ @Override public void SelectSort(int[] array) { for (int i =0;i\u0026lt;array.length;i++){ int min=i; for (int j=i ;j \u0026lt;array.length;j++){ if (array[j] \u0026lt;array[min]){ min = j; } } if (min!=i){ int temp = array[min]; array[min] = array[i]; array[i] = temp; } } } /** * 直接插入排序O(n2) * 依次遍历剩余数组,与当前尾节点比较,决定插入位置,循环插入 * @param array */ @Override public void InsertionSort(int[] array) { int index = 0;//当前排好序的尾节点 while (index \u0026lt; array.length) { int minIndex = index; // 遍历列表最小值坐标 for (int i = index; i \u0026lt; array.length; i++) { minIndex = array[i] \u0026lt; array[minIndex] ? i : minIndex; //找到最小值并记录坐标 } { int temp = array[minIndex]; array[minIndex] = array[index]; array[index] = temp; } //交换位置 for (int i = index-1; i \u0026gt;= 0; i--) { if (array[i] \u0026gt;= array[i + 1]) { int temp = array[i]; array[i] = array[i + 1]; array[i + 1] = temp; } } index++; } } } 分治 分而治之\n动态规划 O(n*m) 题目特点 计数 有多少种方式走到右下角 有多少种方法选出k个数使得和是sum 求最大最小值 从左上角走到右小角路径的最大数字和 最长上升子序列长度 求存在性 取石子游戏,先手是否必胜 能不能选出k个数使得和是sum 解题步骤 确定状态\n知到f[i][j]代表什么 两个意识 最后一步(最优策略中使用的最后一枚硬币a[k]) 化成子问题(最少的硬币拼出更小的面值27-a[k]) 转移方程\nf[X] = min{f[X-2]+1,f[X-5]+1,f[X-7]+1} 初始条件和边界情况\n初始条件:用转移方程算不出来,却又理所应当的值,需要手工定义(F[0]=0) 设定边界,例如不存在小于零的可能,定义小于零为正无穷(不要数组越界) 计算顺序\n当我们计算到F[X]时,F[X-2],f[X-5],F[X-7]都已经得到结果了 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int coinChange(int[] coins, int amount) { int n = coins.length; int M = amount + 1; int[] f = new int[M]; //初始化 f[0] = 0; for (int i = 1; i \u0026lt; M; i++) { f[i] = Integer.MAX_VALUE; for (int j = 0; j \u0026lt; n; j++) { if (i - coins[j] \u0026gt;= 0 \u0026amp;\u0026amp; f[i - coins[j]] != Integer.MAX_VALUE) { // 转移方程 f[i] = Math.min(f[i - coins[j]] + 1, f[i]); } } } if (f[amount] == Integer.MAX_VALUE) { return -1; } return f[amount]; } } 二维:不同路径\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class q62 { public static void main(String[] args) { System.out.println(uniquePaths(3, 2)); } public static int uniquePaths(int m, int n) { int[][] f = new int[m][n]; f[0][0] = 0; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (i == 0 || j == 0) { f[i][j] = 1; continue; } f[i][j] = f[i - 1][j] + f[i][j - 1]; } } return f[m - 1][n - 1]; } } 动态规划初探 坐标型动态规划 给定坐标,怎么走 给定一个序列或网格 需要找到序列中某个/些子序列或网格中的某条路径 某种性质最大/最小 计数 存在性 动态规划方程f[i]中的下表i表示以a[i]为结尾的满足条件的子序列,f[i][j]中的下表i,j代表以格子(i,j)为结尾的满足条件的路径的性质 最大值/最小值 个数 是否存在 坐标型动态规划的初始条件f[0]就是指以a[0]为结尾的子序列的性质 序列型动态规划 : 前i个\u0026hellip;最小/方式数/可行性 在设计动态规划的过程中,发现需要知道油漆钱N-1栋房子的最优策略中,房子N-2的颜色 如果只用f[N-1],将无法区分 解决方法:记录下房子N-2的颜色 在房子N-2是红/蓝/绿的情况下,前N-1栋房子的最小花费 序列+状态 划分型动态规划 优化 空间优化 滚动数组 计算dp[0][0],\u0026hellip;\u0026hellip;dp[0][n-1],计算dp[1][0]\u0026hellip;\u0026hellip;.dp[1][n-1] 计算dp[2][0],\u0026hellip;\u0026hellip;dp[2][n-1],把值写在f[0][0]\u0026hellip;\u0026hellip;.dp[0][n-1]的数组里 同理,dp[3][0],\u0026hellip;\u0026hellip;dp[3][n-1],写在dp[1][0]\u0026hellip;\u0026hellip;.dp[1][n-1]的数组里 最后dp[m-1][n-1]存在dp[0][n-1](或者f[1][n-1]里),直接输出 ","date":"2023-12-14T12:38:12Z","permalink":"https://diandoricon.cloud/p/%E7%AE%97%E6%B3%95-1/","title":"算法-1"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] One line code block 1 \u0026lt;p\u0026gt;A paragraph\u0026lt;/p\u0026gt; List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-09-07T00:00:00Z","permalink":"https://diandoricon.cloud/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Hugo theme Stack supports the creation of interactive image galleries using Markdown. It\u0026rsquo;s powered by PhotoSwipe and its syntax was inspired by Typlog.\nTo use this feature, the image must be in the same directory as the Markdown file, as it uses Hugo\u0026rsquo;s page bundle feature to read the dimensions of the image. External images are not supported.\nSyntax 1 ![Image 1](1.jpg) ![Image 2](2.jpg) Result Photo by mymind and Luke Chesser on Unsplash\n","date":"2023-08-26T00:00:00Z","image":"https://diandoricon.cloud/p/image-gallery/2_hubce42636ecacc1a380b462f3110efcec_37455_120x120_fill_q75_box_smart1.jpg","permalink":"https://diandoricon.cloud/p/image-gallery/","title":"Image gallery"},{"content":"For more details, check out the documentation.\nBilibili video Tencent video YouTube video Generic video file Your browser doesn't support HTML5 video. Here is a link to the video instead. Gist GitLab Quote Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― A famous person, The book they wrote Photo by Codioful on Unsplash\n","date":"2023-08-25T00:00:00Z","image":"https://diandoricon.cloud/p/shortcodes/cover_huec3c3e34981507583e214021ad1b9a4b_12942_120x120_fill_q75_box_smart1.jpg","permalink":"https://diandoricon.cloud/p/shortcodes/","title":"Shortcodes"},{"content":"Stack has built-in support for math typesetting using KaTeX.\nIt\u0026rsquo;s not enabled by default side-wide, but you can enable it for individual posts by adding math: true to the front matter. Or you can enable it side-wide by adding math = true to the params.article section in config.toml.\nInline math This is an inline mathematical expression: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\n1 $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$ Block math $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n1 2 3 $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$ $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi),e^{2 \\pi i \\xi x},d\\xi $$\n1 2 3 $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi $$ ","date":"2023-08-24T00:00:00Z","permalink":"https://diandoricon.cloud/p/math-typesetting/","title":"Math Typesetting"}]